"""
Attack chain analysis module for complex multi-stage vulnerability detection.
"""
import time
from typing import List, Dict, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import json

from core.plugin_base import (
    BasePlugin, ScanTarget, ScanResult, Vulnerability, SeverityLevel
)
from config.logging_config import get_logger


class AttackPhase(Enum):
    """Attack chain phases."""
    RECONNAISSANCE = "reconnaissance"
    INITIAL_ACCESS = "initial_access"
    EXECUTION = "execution"
    PERSISTENCE = "persistence"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    LATERAL_MOVEMENT = "lateral_movement"
    COLLECTION = "collection"
    COMMAND_CONTROL = "command_control"
    EXFILTRATION = "exfiltration"
    IMPACT = "impact"


@dataclass
class AttackStep:
    """Represents a single step in an attack chain."""
    id: str
    phase: AttackPhase
    name: str
    description: str
    vulnerability_id: str
    prerequisites: List[str] = field(default_factory=list)
    outputs: List[str] = field(default_factory=list)
    confidence: float = 0.0
    severity: SeverityLevel = SeverityLevel.INFO
    evidence: str = ""
    mitigation: str = ""
    
    def __post_init__(self):
        if not self.evidence:
            self.evidence = f"Attack step: {self.name}"


@dataclass
class AttackChain:
    """Represents a complete attack chain."""
    id: str
    name: str
    description: str
    steps: List[AttackStep] = field(default_factory=list)
    total_severity: SeverityLevel = SeverityLevel.INFO
    confidence: float = 0.0
    impact_description: str = ""
    
    def add_step(self, step: AttackStep) -> None:
        """Add a step to the attack chain."""
        self.steps.append(step)
        self._update_metrics()
    
    def _update_metrics(self) -> None:
        """Update chain metrics based on steps."""
        if not self.steps:
            return
        
        # Calculate average confidence
        self.confidence = sum(step.confidence for step in self.steps) / len(self.steps)
        
        # Determine overall severity
        severities = [step.severity for step in self.steps]
        if SeverityLevel.CRITICAL in severities:
            self.total_severity = SeverityLevel.CRITICAL
        elif SeverityLevel.HIGH in severities:
            self.total_severity = SeverityLevel.HIGH
        elif SeverityLevel.MEDIUM in severities:
            self.total_severity = SeverityLevel.MEDIUM
        else:
            self.total_severity = SeverityLevel.LOW
    
    def is_viable(self) -> bool:
        """Check if the attack chain is viable."""
        return len(self.steps) >= 2 and self.confidence > 0.3


class AttackChainAnalyzer(BasePlugin):
    """Plugin for analyzing complex multi-stage attack chains."""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.logger = get_logger(self.__class__.__name__)
        self.min_chain_length = config.get('min_chain_length', 2)
        self.min_confidence = config.get('min_confidence', 0.3)
        self.max_chains = config.get('max_chains', 10)
        
        # Initialize attack templates
        self._init_attack_templates()
    
    def _init_attack_templates(self):
        """Initialize predefined attack chain templates."""
        self.attack_templates = {
            'web_app_compromise': {
                'name': 'Web Application Compromise Chain',
                'description': 'Multi-stage web application attack leading to system compromise',
                'phases': [
                    AttackPhase.RECONNAISSANCE,
                    AttackPhase.INITIAL_ACCESS,
                    AttackPhase.EXECUTION,
                    AttackPhase.PRIVILEGE_ESCALATION
                ]
            },
            'lateral_movement': {
                'name': 'Network Lateral Movement Chain',
                'description': 'Attack chain for moving laterally through network',
                'phases': [
                    AttackPhase.INITIAL_ACCESS,
                    AttackPhase.CREDENTIAL_ACCESS,
                    AttackPhase.LATERAL_MOVEMENT,
                    AttackPhase.PERSISTENCE
                ]
            },
            'data_exfiltration': {
                'name': 'Data Exfiltration Chain',
                'description': 'Attack chain focused on data theft',
                'phases': [
                    AttackPhase.INITIAL_ACCESS,
                    AttackPhase.DISCOVERY,
                    AttackPhase.COLLECTION,
                    AttackPhase.EXFILTRATION
                ]
            }
        }
        
        # Vulnerability patterns for attack step identification
        self.vuln_patterns = {
            'sql_injection': {
                'phases': [AttackPhase.INITIAL_ACCESS, AttackPhase.CREDENTIAL_ACCESS],
                'outputs': ['database_access', 'credentials', 'sensitive_data'],
                'prerequisites': ['web_application'],
                'confidence_boost': 0.8
            },
            'xss': {
                'phases': [AttackPhase.INITIAL_ACCESS, AttackPhase.EXECUTION],
                'outputs': ['session_hijack', 'client_side_code_execution'],
                'prerequisites': ['web_application'],
                'confidence_boost': 0.6
            },
            'rce': {
                'phases': [AttackPhase.EXECUTION, AttackPhase.PRIVILEGE_ESCALATION],
                'outputs': ['system_access', 'command_execution'],
                'prerequisites': ['application_access'],
                'confidence_boost': 0.9
            },
            'open_port': {
                'phases': [AttackPhase.RECONNAISSANCE, AttackPhase.INITIAL_ACCESS],
                'outputs': ['service_enumeration', 'attack_surface'],
                'prerequisites': [],
                'confidence_boost': 0.3
            },
            'weak_credentials': {
                'phases': [AttackPhase.INITIAL_ACCESS, AttackPhase.CREDENTIAL_ACCESS],
                'outputs': ['authentication_bypass', 'account_access'],
                'prerequisites': ['login_interface'],
                'confidence_boost': 0.7
            },
            'directory_traversal': {
                'phases': [AttackPhase.INITIAL_ACCESS, AttackPhase.DISCOVERY],
                'outputs': ['file_system_access', 'sensitive_files'],
                'prerequisites': ['web_application'],
                'confidence_boost': 0.5
            }
        }
    
    def get_name(self) -> str:
        return "AttackChainAnalyzer"
    
    def get_description(self) -> str:
        return "Analyzes complex multi-stage attack chains and identifies attack paths"
    
    def get_version(self) -> str:
        return "1.0.0"
    
    def is_applicable(self, target: ScanTarget) -> bool:
        """Chain analysis is applicable when multiple vulnerabilities are found."""
        return True
    
    def scan(self, target: ScanTarget) -> ScanResult:
        """Perform attack chain analysis."""
        result = ScanResult(target, self.get_name())
        
        try:
            self.logger.info(f"Starting attack chain analysis on {target.host}")
            
            # This would typically be called after other plugins have run
            # For now, we'll analyze based on target metadata or create sample data
            vulnerabilities = self._get_existing_vulnerabilities(target)
            
            if len(vulnerabilities) < 2:
                self.logger.info("Insufficient vulnerabilities for chain analysis")
                result.finish("completed")
                return result
            
            # Generate attack steps from vulnerabilities
            attack_steps = self._generate_attack_steps(vulnerabilities, target)
            
            # Build attack chains
            attack_chains = self._build_attack_chains(attack_steps)
            
            # Create vulnerabilities for viable attack chains
            for chain in attack_chains:
                if chain.is_viable():
                    vulnerability = self._create_chain_vulnerability(target, chain)
                    result.add_vulnerability(vulnerability)
            
            result.metadata['attack_steps_generated'] = len(attack_steps)
            result.metadata['attack_chains_found'] = len(attack_chains)
            result.metadata['viable_chains'] = len([c for c in attack_chains if c.is_viable()])
            
            self.logger.info(
                f"Attack chain analysis completed on {target.host}. "
                f"Found {len(attack_chains)} attack chains from {len(attack_steps)} steps."
            )
            
        except Exception as e:
            self.logger.error(f"Attack chain analysis failed on {target.host}: {e}")
            result.finish("error", str(e))
            return result
        
        result.finish("completed")
        return result
    
    def _get_existing_vulnerabilities(self, target: ScanTarget) -> List[Dict[str, Any]]:
        """Get existing vulnerabilities for the target."""
        # In a real implementation, this would get vulnerabilities from previous scans
        # For demonstration, we'll create sample vulnerabilities
        sample_vulns = []
        
        if target.ports:
            for port in target.ports:
                if port in [80, 443, 8080]:
                    sample_vulns.extend([
                        {
                            'type': 'sql_injection',
                            'severity': 'critical',
                            'confidence': 0.9,
                            'port': port,
                            'service': 'http',
                            'details': 'SQL injection in login form'
                        },
                        {
                            'type': 'xss',
                            'severity': 'high',
                            'confidence': 0.8,
                            'port': port,
                            'service': 'http',
                            'details': 'Reflected XSS in search parameter'
                        }
                    ])
                elif port == 22:
                    sample_vulns.append({
                        'type': 'weak_credentials',
                        'severity': 'high',
                        'confidence': 0.7,
                        'port': port,
                        'service': 'ssh',
                        'details': 'Weak SSH credentials detected'
                    })
                else:
                    sample_vulns.append({
                        'type': 'open_port',
                        'severity': 'medium',
                        'confidence': 0.5,
                        'port': port,
                        'service': 'unknown',
                        'details': f'Open port {port} detected'
                    })
        
        return sample_vulns
    
    def _generate_attack_steps(self, vulnerabilities: List[Dict[str, Any]], 
                             target: ScanTarget) -> List[AttackStep]:
        """Generate attack steps from vulnerabilities."""
        attack_steps = []
        
        for i, vuln in enumerate(vulnerabilities):
            vuln_type = vuln.get('type', 'unknown')
            pattern = self.vuln_patterns.get(vuln_type, {})
            
            if not pattern:
                continue
            
            # Create attack steps for each applicable phase
            phases = pattern.get('phases', [])
            if not isinstance(phases, list):
                continue
                
            for phase in phases:
                if not isinstance(phase, AttackPhase):
                    continue
                    
                step_id = f"step_{i}_{phase.value}"
                
                prerequisites = pattern.get('prerequisites', [])
                outputs = pattern.get('outputs', [])
                confidence_boost = pattern.get('confidence_boost', 0.5)
                
                # Ensure we have proper types
                if not isinstance(prerequisites, list):
                    prerequisites = []
                else:
                    # Convert to string list if needed
                    prerequisites = [str(p) for p in prerequisites]
                    
                if not isinstance(outputs, list):
                    outputs = []
                else:
                    # Convert to string list if needed
                    outputs = [str(o) for o in outputs]
                    
                if not isinstance(confidence_boost, (int, float)):
                    confidence_boost = 0.5
                
                step = AttackStep(
                    id=step_id,
                    phase=phase,
                    name=f"{vuln_type.replace('_', ' ').title()} - {phase.value.replace('_', ' ').title()}",
                    description=self._generate_step_description(vuln_type, phase, vuln),
                    vulnerability_id=f"vuln_{i}",
                    prerequisites=prerequisites,
                    outputs=outputs,
                    confidence=vuln.get('confidence', 0.5) * confidence_boost,
                    severity=self._map_severity(vuln.get('severity', 'medium')),
                    evidence=vuln.get('details', ''),
                    mitigation=self._generate_mitigation(vuln_type)
                )
                
                attack_steps.append(step)
        
        return attack_steps
    
    def _generate_step_description(self, vuln_type: str, phase: AttackPhase, 
                                 vuln: Dict[str, Any]) -> str:
        """Generate description for an attack step."""
        descriptions = {
            ('sql_injection', AttackPhase.INITIAL_ACCESS): 
                "Use SQL injection to bypass authentication and gain initial access",
            ('sql_injection', AttackPhase.CREDENTIAL_ACCESS): 
                "Extract user credentials from database using SQL injection",
            ('xss', AttackPhase.INITIAL_ACCESS): 
                "Execute malicious JavaScript to hijack user sessions",
            ('xss', AttackPhase.EXECUTION): 
                "Use XSS to execute arbitrary code in victim's browser",
            ('rce', AttackPhase.EXECUTION): 
                "Execute arbitrary commands on the target system",
            ('rce', AttackPhase.PRIVILEGE_ESCALATION): 
                "Use RCE to escalate privileges on the system",
            ('open_port', AttackPhase.RECONNAISSANCE): 
                "Identify open services for potential attack vectors",
            ('open_port', AttackPhase.INITIAL_ACCESS): 
                "Exploit service vulnerabilities to gain initial access",
            ('weak_credentials', AttackPhase.INITIAL_ACCESS): 
                "Use weak credentials to authenticate to the system",
            ('weak_credentials', AttackPhase.CREDENTIAL_ACCESS): 
                "Leverage weak credentials to access additional accounts",
            ('directory_traversal', AttackPhase.INITIAL_ACCESS): 
                "Use directory traversal to access sensitive files",
            ('directory_traversal', AttackPhase.DISCOVERY): 
                "Enumerate file system structure and locate sensitive data"
        }
        
        key = (vuln_type, phase)
        return descriptions.get(key, f"Exploit {vuln_type} vulnerability in {phase.value} phase")
    
    def _generate_mitigation(self, vuln_type: str) -> str:
        """Generate mitigation advice for vulnerability type."""
        mitigations = {
            'sql_injection': "Use parameterized queries and input validation",
            'xss': "Implement output encoding and Content Security Policy",
            'rce': "Validate and sanitize all user input, use safe APIs",
            'open_port': "Close unnecessary ports and services",
            'weak_credentials': "Enforce strong password policies",
            'directory_traversal': "Implement proper access controls and input validation"
        }
        return mitigations.get(vuln_type, "Apply security best practices")
    
    def _map_severity(self, severity_str: str) -> SeverityLevel:
        """Map severity string to SeverityLevel enum."""
        mapping = {
            'critical': SeverityLevel.CRITICAL,
            'high': SeverityLevel.HIGH,
            'medium': SeverityLevel.MEDIUM,
            'low': SeverityLevel.LOW,
            'info': SeverityLevel.INFO
        }
        return mapping.get(severity_str.lower(), SeverityLevel.MEDIUM)
    
    def _build_attack_chains(self, attack_steps: List[AttackStep]) -> List[AttackChain]:
        """Build attack chains from individual steps."""
        chains = []
        
        # Group steps by attack template
        for template_name, template in self.attack_templates.items():
            chain = self._build_chain_from_template(attack_steps, template_name, template)
            if chain and len(chain.steps) >= self.min_chain_length:
                chains.append(chain)
        
        # Build custom chains based on step dependencies
        custom_chains = self._build_custom_chains(attack_steps)
        chains.extend(custom_chains)
        
        # Sort by confidence and limit results
        chains.sort(key=lambda x: x.confidence, reverse=True)
        return chains[:self.max_chains]
    
    def _build_chain_from_template(self, attack_steps: List[AttackStep], 
                                 template_name: str, template: Dict[str, Any]) -> Optional[AttackChain]:
        """Build an attack chain from a template."""
        chain = AttackChain(
            id=f"chain_{template_name}_{int(time.time())}",
            name=template['name'],
            description=template['description']
        )
        
        # Find steps for each phase in the template
        required_phases = template.get('phases', [])
        
        for phase in required_phases:
            # Find the best step for this phase
            phase_steps = [step for step in attack_steps if step.phase == phase]
            if phase_steps:
                # Select step with highest confidence
                best_step = max(phase_steps, key=lambda x: x.confidence)
                chain.add_step(best_step)
        
        return chain if chain.steps else None
    
    def _build_custom_chains(self, attack_steps: List[AttackStep]) -> List[AttackChain]:
        """Build custom attack chains based on step dependencies."""
        chains = []
        
        # Simple chain building: connect steps where outputs match prerequisites
        used_steps = set()
        
        for start_step in attack_steps:
            if start_step.id in used_steps:
                continue
            
            chain = AttackChain(
                id=f"custom_chain_{start_step.id}_{int(time.time())}",
                name=f"Custom Attack Chain from {start_step.name}",
                description=f"Attack chain starting with {start_step.name}"
            )
            
            chain.add_step(start_step)
            used_steps.add(start_step.id)
            
            # Find subsequent steps
            current_outputs = set(start_step.outputs)
            
            while current_outputs:
                next_step = None
                for step in attack_steps:
                    if (step.id not in used_steps and 
                        any(prereq in current_outputs for prereq in step.prerequisites)):
                        next_step = step
                        break
                
                if next_step:
                    chain.add_step(next_step)
                    used_steps.add(next_step.id)
                    current_outputs.update(next_step.outputs)
                else:
                    break
            
            if len(chain.steps) >= self.min_chain_length and chain.confidence >= self.min_confidence:
                chains.append(chain)
        
        return chains
    
    def _create_chain_vulnerability(self, target: ScanTarget, chain: AttackChain) -> Vulnerability:
        """Create a vulnerability object for an attack chain."""
        # Generate detailed evidence
        evidence_parts = [
            f"Attack Chain: {chain.name}",
            f"Description: {chain.description}",
            f"Steps: {len(chain.steps)}",
            f"Overall Confidence: {chain.confidence:.2f}",
            "",
            "Attack Steps:"
        ]
        
        for i, step in enumerate(chain.steps, 1):
            evidence_parts.extend([
                f"{i}. {step.name}",
                f"   Phase: {step.phase.value}",
                f"   Confidence: {step.confidence:.2f}",
                f"   Evidence: {step.evidence}",
                ""
            ])
        
        # Generate solution
        solution_parts = [
            f"This attack chain can be mitigated by addressing the following vulnerabilities:",
            ""
        ]
        
        for step in chain.steps:
            solution_parts.append(f"- {step.name}: {step.mitigation}")
        
        solution_parts.extend([
            "",
            "Additional recommendations:",
            "- Implement defense in depth",
            "- Monitor for attack patterns",
            "- Regular security assessments",
            "- Incident response procedures"
        ])
        
        return Vulnerability(
            id=chain.id,
            name=f"Multi-Stage Attack Chain: {chain.name}",
            description=f"Complex attack chain with {len(chain.steps)} steps that could lead to "
                       f"system compromise. {chain.description}",
            severity=chain.total_severity,
            confidence=chain.confidence,
            target=target.host,
            evidence="\n".join(evidence_parts),
            solution="\n".join(solution_parts),
            references=[
                "https://attack.mitre.org/",
                "https://owasp.org/www-community/attacks/",
                "https://www.sans.org/reading-room/whitepapers/testing/paper/36197"
            ]
        )
    
    def analyze_existing_scan_results(self, scan_results: List[ScanResult]) -> List[AttackChain]:
        """Analyze existing scan results to identify attack chains."""
        all_vulnerabilities = []
        
        # Collect all vulnerabilities from scan results
        for result in scan_results:
            for vuln in result.vulnerabilities:
                vuln_dict = {
                    'type': self._classify_vulnerability_type(vuln),
                    'severity': vuln.severity.value,
                    'confidence': vuln.confidence,
                    'port': vuln.port,
                    'service': vuln.service,
                    'details': vuln.evidence
                }
                all_vulnerabilities.append(vuln_dict)
        
        if len(all_vulnerabilities) < 2:
            return []
        
        # Generate attack steps and build chains
        target = scan_results[0].target if scan_results else ScanTarget("unknown")
        attack_steps = self._generate_attack_steps(all_vulnerabilities, target)
        return self._build_attack_chains(attack_steps)
    
    def _classify_vulnerability_type(self, vulnerability: Vulnerability) -> str:
        """Classify vulnerability type based on name and description."""
        name_lower = vulnerability.name.lower()
        desc_lower = vulnerability.description.lower()
        
        if 'sql injection' in name_lower or 'sql injection' in desc_lower:
            return 'sql_injection'
        elif 'xss' in name_lower or 'cross-site scripting' in name_lower:
            return 'xss'
        elif 'rce' in name_lower or 'remote code execution' in name_lower or 'command injection' in name_lower:
            return 'rce'
        elif 'open port' in name_lower:
            return 'open_port'
        elif 'auth' in name_lower and 'bypass' in name_lower:
            return 'weak_credentials'
        elif 'directory traversal' in name_lower or 'path traversal' in name_lower:
            return 'directory_traversal'
        else:
            return 'unknown'